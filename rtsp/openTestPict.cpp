#define GLUT_DISABLE_ATEXIT_HACK  
#include "glew/glew.h"  
#include "freeglut\freeglut.h"  
//#pragma comment(lib, "glut32.lib")  
  
GLubyte zebra[]={0x00,0x00,0x00,0x00,  
0x37,0x20,0x00,0x00,  
0x13,0x60,0x00,0x00,  
0x10,0x60,0x00,0x00,  
0x14,0x60,0x00,0x00,  
0x16,0x38,0x00,0x00,  
0x06,0x18,0x00,0x00,  
0x07,0x10,0x00,0x00,  
0x07,0x40,0x00,0x00,  
0x03,0x60,0x00,0x00,  
0x03,0x70,0x00,0x00,  
0x01,0x70,0x00,0x3e,  
0x02,0x78,0x0a,0x78,  
0x01,0x18,0x01,0x60,  
0x01,0x48,0x0a,0x08,  
0x00,0x62,0x14,0x00,  
0x00,0xf6,0x11,0xf0,  
0x00,0xfa,0x43,0xe0,  
0x00,0x7c,0xea,0x60,  
0x00,0x3d,0xcb,0x60,  
0x00,0x19,0x9d,0x40,  
0x00,0x08,0x22,0xc0,  
0x00,0x00,0x09,0x80,  
0x00,0x02,0x40,0x80,  
0x00,0x01,0x1b,0x80,  
0x00,0x01,0x08,0x80,  
0x00,0x00,0x00,0x00,  
0x00,0x00,0x28,0x00,  
0x00,0x00,0x29,0x00,  
0x00,0x00,0x49,0x80,  
0x00,0x00,0x99,0x80,  
0x00,0x00,0x00,0x00,  
};  
  
void Initialization(void);  
void OnDisPlay(void);  
void OnReshape(int,int);  
  
static int g_w = -1;
static int g_h = -1;
static void *ptr = NULL;
void testPict(int argc,char* argv[], int width, int height, void *bitmap)  
{  
    glutInit(&argc,argv);  
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);  
    glutInitWindowSize(600,480);  
    glutCreateWindow("EXAM601");  
  
	g_w = width;
	g_h = height;
	ptr = bitmap;
    glutReshapeFunc(OnReshape);  
    glutDisplayFunc(OnDisPlay);  
  
    Initialization();  
  
    glutMainLoop();  
}  
  
void Initialization(void)  
{  
    glClearColor(1,1,1,1);  
}  
  
void OnDisPlay(void)  
{  
    glClear(GL_COLOR_BUFFER_BIT);  
  
    glColor3f(1,0,0);  
  
    glRasterPos2i(-3,-3); //指定当前光栅位置  
    //glBitmap(g_w, g_h, 0, 0, 0, 0, (GLubyte *)ptr);  
	glDrawPixels(g_w, g_h, GL_BGR_EXT, GL_UNSIGNED_BYTE, ptr);
    glPointSize(5);  
    glBegin(GL_POINTS);  
    glColor3f(0,1,0);  
    glVertex2i(0,0);  
    glEnd();  
  
    glutSwapBuffers();  
}  
  
void OnReshape(int w,int h)  
{  
    GLfloat aspect =(GLfloat)w/(GLfloat)h;  
    GLfloat nRange=100.0f;  
  
    glViewport(0,0,w,h);  
  
    glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影模式  
    glLoadIdentity();  
  
    //设置三维投影区  
  
    if (w<=h)  
        glOrtho(-nRange,nRange,-nRange*aspect,nRange*aspect,-nRange,nRange);  
    else  
        glOrtho(-nRange,nRange,-nRange/aspect,nRange/aspect,-nRange,nRange);  
}  